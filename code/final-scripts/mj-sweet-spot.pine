//@version=4
study("MJ - Sweet Spot", overlay=true)

//////////////////////////////////////////////////////////////////
// 
// ==== DATE UTILS ==== 
// 
//////////////////////////////////////////////////////////////////

int MS_PER_MINUTE = 1000 * 60
int MS_PER_HOUR = MS_PER_MINUTE * 60
int MS_PER_DAY = MS_PER_HOUR * 24

_getFutureTimeNBarsFromNow(numBars) => time + ( ( time - time[1] ) * numBars )

_getPastTimeNBarsBackFromNow(numBars) => time - ( ( time - time[1] ) * numBars )

_getTimeNBarsFromNow(numBars) => numBars > 0 ? _getFutureTimeNBarsFromNow(numBars) : _getPastTimeNBarsBackFromNow(numBars * -1)

_currentBarTime() => time(timeframe.period)

_calcBarsPerHour() =>
    int barLengthInMinutes = (time - time[1]) / MS_PER_MINUTE
    int barsElapsedThisHour = minute / barLengthInMinutes 
    int barsPerHour = 60 / barLengthInMinutes

_calcBarsPerDay() => _calcBarsPerHour() * 24

_timeElapsedTodayInMs() => (MS_PER_HOUR * hour) - (MS_PER_MINUTE * minute) - (1000 * second)
_timeElapsedThisHourInMs() => (MS_PER_MINUTE * minute) + (1000 * second)

_getTimeAtBeginningOfToday() => timenow - _timeElapsedTodayInMs()
    
_getTimeAtStartOfHourNHoursAgo(numHours) => 
    timeElapsedSinceStartInMs = _timeElapsedThisHourInMs() + (numHours * MS_PER_HOUR)
    timenow - timeElapsedSinceStartInMs


// *** TOOD ***
// _getBarIndexAtTime() => 
// _getBarIndexForTimestamp(_timestamp) => 

_getBarsElapsedAndRemainingForCurrentHour() =>
    int barLengthInMinutes = (time - time[1]) / MS_PER_MINUTE
    int barsElapsedThisHour = minute / barLengthInMinutes 
    int barsPerHour = 60 / barLengthInMinutes
    int barsRemainingThisHour = barsPerHour - barsElapsedThisHour
    [barsElapsedThisHour, barsRemainingThisHour]

_getStartTimeNDaysBack(numDays) => 
    // int barsPerDay = _calcBarsPerDay()
    // int numBarsElapsedToday = 0
    // int barsElapsedSinceCutoff = numBarsElapsedToday + (barsPerDay * numDays)
    // _getPastTimeNBarsBackFromNow(barsElapsedSinceCutoff)
    _getTimeAtBeginningOfToday() - (numDays * MS_PER_DAY)    

_isCurrentDay() => 
    currentBarTime = time(timeframe.period)
    currentBarTime > (timenow - MS_PER_DAY)   

_isInSession(timeRange) =>
    not na(time(timeframe.period, timeRange))

_isFirstOrLastFiveMinOfAnyHour() => 
    _isInSession('2355-0005') or _isInSession('0055-0105') or _isInSession('0155-0205') or _isInSession('0255-0305') or _isInSession('0355-0405') or _isInSession('0455-0505') or _isInSession('0555-0605') or _isInSession('0655-0705') or _isInSession('0755-0805') or _isInSession('0855-0905') or _isInSession('0955-1005') or _isInSession('1055-1105') or _isInSession('1155-1205') or _isInSession('1255-1305') or _isInSession('1355-1405') or _isInSession('1455-1505') or _isInSession('1555-1605') or _isInSession('1655-1705') or _isInSession('1755-1805') or _isInSession('1855-1905') or _isInSession('1955-2005') or _isInSession('2055-2105') or _isInSession('2155-2205') or _isInSession('2255-2305')    

_isLastBarForCurrentTimeframeAtResolution(Resolution) =>
    t = time(Resolution, session.regular) // e.g. "1440" = Daily Resolution
    not na(t[1]) and na(t) or t[1] < t

_isFirstBarForCurrentTimeframeAtResolution(Resolution) =>
    // e.g. current timeframe: 1min, resolution: '60' => return true for the first minute of the hour
    // e.g. current timeframe: 5min, resolution: '60' => return true for the first 5 minutes of the hour
    t = time(Resolution)
    previousBar = t[1]
    currentBar = t
    not na(currentBar) and ( na(previousBar) or currentBar > previousBar)

// new_bar: check if we're on a new bar within the session in a given resolution
new_bar(res) => change(time(res)) != 0

_getTimeframeMultiplier() => 
    _multiplier = timeframe.isseconds 
     ? timeframe.multiplier / 60 
     : timeframe.isdaily
       ? timeframe.multiplier * 1440
       : timeframe.isweekly
         ? timeframe.multiplier * 1440 * 7
         : timeframe.ismonthly 
           ? timeframe.multiplier * 1440 * 30 
           : timeframe.multiplier

//////////////////////////////////////////////////////////////////
// 
// ==== PLOT UTILS ==== 
// 
//////////////////////////////////////////////////////////////////

_drawLabelledLine(lineId, x1, x2, y, _color, _width, _style, _extend, labelText, labelStyle, labelColor, labelTextColor, labelSize, showLabel, labelOffsetInBars, showPrice) => 
    // x1 and x2 are in time (not bars)

    _lineId = lineId

    if na(_lineId)
        _lineId := line.new(x1, y, x2, y, xloc.bar_time, _extend)
    
    line.set_xy1(_lineId, x1, y)
    line.set_xy2(_lineId, x2, y)
    line.set_color(_lineId, _color)
    line.set_width(_lineId, _width)
    line.set_style(_lineId, _style)

    if not na(_lineId[1])
        line.delete(_lineId[1])

    // ----------------
    // draw the label
    // ----------------

    if showLabel
        _labelText = showPrice ? labelText + ' (' + tostring(y) + ')' : labelText
        timePerBar = time[0] - time[1]
        labelTime = x2 + (labelOffsetInBars * timePerBar)
        labelId = label.new(labelTime, y, _labelText, textcolor=labelTextColor, style=labelStyle, size=labelSize, xloc=xloc.bar_time, color=labelColor)
        label.delete(labelId[1])

    _lineId

_print(_text) => var _label = label.new(bar_index, na, _text, xloc.bar_index, yloc.price, color(na), label.style_none, color.gray, size.large, text.align_left), label.set_xy(_label, bar_index, highest(10)[1]), label.set_text(_label, _text)
_printNum(_num) => _print(tostring(_num))


//////////////////////////////////////////////////////////////////
// 
// ==== SWEET SPOT ==== 
// 
//////////////////////////////////////////////////////////////////

showWhole = input(true, 'Show Whole')
showHalf = input(true, 'Show Half')
showQuarter = input(true, 'Show Quarter')
plotRangeInMultiplesOfWhole = input(2, 'Plot Range (in multiples of the whole)', tooltip='Example:  plotRange=2.  open = 31,795.  This would plot a line at each whole level between 34k (32+2) and 30k (32-2).', minval=0)
wholeLevelOverride = input(0, 'Whole Level Override', minval=0, tooltip='Only active if greater than 0')

lineOffset = input(43, 'Line Offset (in bars)')
lineLength = input(20, 'Line Length (in bars)')
labelOffset = input(-4, 'Label Offset (in bars)')

lineWidth = input(2, 'Line Width', options=[1,2,3,4])

lineStyle = input(line.style_solid, 'Line Style', options=[line.style_solid, line.style_dashed, line.style_dotted])
lineExtendWhole = input(extend.none, 'Line Extend Whole', options=[extend.none, extend.left, extend.right, extend.both])
lineExtendHalf = input(extend.none, 'Line Extend Half', options=[extend.none, extend.left, extend.right, extend.both])
lineExtendQuarter = input(extend.none, 'Line Extend Quarter', options=[extend.none, extend.left, extend.right, extend.both])
labelStyle = input(label.style_none, 'Label Style', options=[label.style_none, label.style_label_up, label.style_label_upper_right, label.style_label_right, label.style_label_lower_right, label.style_label_down, label.style_label_lower_left, label.style_label_left, label.style_label_upper_left, label.style_label_center, label.style_triangleup, label.style_triangledown, label.style_arrowup, label.style_arrowdown, label.style_xcross, label.style_cross, label.style_flag, label.style_circle])
labelTextColor = input(color.white, 'Label Text Color')
labelSize = input(size.normal, 'Label Size', options=[size.auto, size.tiny, size.small, size.normal, size.large])
showLabels = input(true, 'Show Labels?')

COLOR_PEACH = #e57373

wholeColor = input(color.new(COLOR_PEACH, 10), 'Whole Color')
halfColor = input(color.new(COLOR_PEACH, 40), 'Half Color')
quarterColor = input(color.new(COLOR_PEACH, 70), 'Quarter Color')

_getLevels() => 
    wholeLevel = 
         wholeLevelOverride > 0 ? wholeLevelOverride :
         open > 5000 ? 1000 :
         open > 500 ? 100 :
         open > 50 ? 10 : 
         open > 5 ? 1 : 
         open > 0.5 ? 0.1 : 
         open > 0.05 ? 0.01 :
         0.001
    halfLevel = wholeLevel / 2
    quarterLevel = wholeLevel / 4
    [wholeLevel, halfLevel, quarterLevel]

_getNearestWhole(wholeLevel) => 
    currentPrice = open[0]
    wholeLevel == 0 ? currentPrice : currentPrice - (currentPrice % wholeLevel)

_getRange(wholeLevel, nearestWhole) => 
    _min = nearestWhole - (wholeLevel * plotRangeInMultiplesOfWhole)
    _max = nearestWhole + (wholeLevel * plotRangeInMultiplesOfWhole)
    [_min, _max]    

 
_getItemAtIndex(arrayId, index) => 
    array.size(arrayId) >= index + 1 ? array.get(arrayId, index) : na   

[wholeLevel, halfLevel, quarterLevel] = _getLevels()
nearestWhole = _getNearestWhole(wholeLevel)
[_min, _max] = _getRange(wholeLevel[0], nearestWhole)

var float[] wholeValues = array.new_float(0)
var float[] halfValues = array.new_float(0)
var float[] quarterValues = array.new_float(0)

_buildArrays() => 
    array.clear(wholeValues)
    array.clear(halfValues)
    array.clear(quarterValues)

    wholeLoopSize = 1 + (2 * plotRangeInMultiplesOfWhole * 1)
    halfLoopSize = 1 + (2 * plotRangeInMultiplesOfWhole * 2)
    quarterLoopSize = 1 + (2 * plotRangeInMultiplesOfWhole * 4)

    for _i = 1 to wholeLoopSize
        valueToPush = _min + (_i * wholeLevel)
        isValid = true
        if isValid
            array.push(wholeValues, valueToPush)

    for _i = 1 to halfLoopSize
        valueToPush = _min + (_i * halfLevel)
        isValid = not array.includes(wholeValues, valueToPush)
        if isValid
            array.push(halfValues, valueToPush)

    for _i = 1 to quarterLoopSize
        valueToPush = _min + (_i * quarterLevel)
        isValid = not array.includes(wholeValues, valueToPush) and not array.includes(halfValues, valueToPush)
        if isValid
            array.push(quarterValues, valueToPush)


_buildArrays()

_getLinePlotValues(lineOffset, lineLength, labelOffset) => 
    x1 = _getTimeNBarsFromNow(lineOffset)
    x2 = _getTimeNBarsFromNow(lineOffset + lineLength)
    timePerBar = time[0] - time[1]
    labelTime = x2 + (labelOffset * timePerBar)
    [x1, x2, labelTime]

var line[] wholeLines = array.new_line(0)
var line[] halfLines = array.new_line(0)
var line[] quarterLines = array.new_line(0)
var label[] wholeLabels = array.new_label(0)
var label[] halfLabels = array.new_label(0)
var label[] quarterLabels = array.new_label(0)

[x1, x2, labelTime] = _getLinePlotValues(lineOffset, lineLength, labelOffset)

_drawLinesAndLabels(linesArray, labelsArray, valuesArray, _color, lineExtend) => 
    isNew = array.size(linesArray) == 0
    size = array.size(valuesArray)

    for _i = 0 to (size -1)
        _price = array.get(valuesArray, _i)
        
        line lineId = line.new(
             x1=x1, 
             y1=_price, 
             x2=x2, 
             y2=_price, 
             xloc=xloc.bar_time, 
             extend=lineExtend, 
             color=_color, 
             style=lineStyle, 
             width=lineWidth)
        line.set_xy1(lineId, x1, _price)
        line.set_xy2(lineId, x2, _price)
        array.push(linesArray, lineId)
        
        // create a label on the last bar (aka the current bar)
        // the `var` keyword will make it only create once
        // set_xy, and set_text will update the label
        labelId = label.new(
             x=labelTime,
             y=_price,
             text=tostring(_price),
             textcolor=labelTextColor,
             style=labelStyle,
             size=labelSize,
             xloc=xloc.bar_time,
             color=_color)

        // label.set_xy(labelId, x1, _price)
        // label.set_text(labelId, tostring(_price))
        array.push(labelsArray, labelId)

        // cleanup
        if not isNew 
            lineToDelete = array.shift(linesArray)
            line.delete(lineToDelete)
            labelToDelete = array.shift(labelsArray)
            label.delete(labelToDelete)

if barstate.islast
    _drawLinesAndLabels(wholeLines, wholeLabels, wholeValues, wholeColor, lineExtendWhole)
    _drawLinesAndLabels(halfLines, halfLabels, halfValues, halfColor, lineExtendHalf)
    _drawLinesAndLabels(quarterLines, quarterLabels, quarterValues, quarterColor, lineExtendQuarter)



//////////////////////////////////////////////////////////////////
// 
// ==== MULTI TF METER ==== 
// 
//////////////////////////////////////////////////////////////////

// 1, 5, 15, 30, 60, 240, D, W, M


///////////////////////
// PVSRA Color
///////////////////////
groupMeterLines = 'Meter Lines'
groupColors = 'Colors'

usePvsraColor = input(true, 'Use PVSRA Color', group=groupMeterLines, tooltip='Show the PVSRA Color for the given resolution instead of Red/Green')

meterLabelOffset = input(10, 'Label Offset (in bars)', group=groupMeterLines)
meterLabelWidthInBars = input(3, 'Meter Label Width (in bars)', group=groupMeterLines)
meterLabelSize = input(size.large, 'Label Size', options=[size.auto, size.tiny, size.small, size.normal, size.large])
meterMarginMultiple = input(0.15, 'Meter Margin Multiple', group=groupMeterLines, minval=-2, maxval=2, step=0.05)

climaxVolBullColor = input(color.lime, 'Climax Bull Color', group=groupMeterLines)
climaxVolBearColor = input(color.red, 'Climax Bear Color', group=groupMeterLines)
aboveAvgVolBullColor = input(color.blue, 'Above Average Volume Bull Color', group=groupMeterLines)
aboveAvgVolBearColor = input(color.fuchsia, 'Above Average Volume Bear Color', group=groupMeterLines)
standardVolBullColor = input(#999999, 'Standard Volume Bull Color', group=groupMeterLines)
standardVolBearColor = input(#4d4d4d, 'Standard Volume Bear Color', group=groupMeterLines)
disabledMeterColor = input(#434651, 'Disabled Color', group=groupMeterLines,
     tooltip='Candle meters can only show for higher timeframes.  This will show if the meter is disabled on the current timeframe')

_security(expression, _resolution) => 
     security(syminfo.tickerid, _resolution, expression, barmerge.gaps_off, barmerge.lookahead_on)

_getBarColorByVolWeight(volWeight, _open, _close) => 
    if usePvsraColor
        if _close > _open
            volWeight == 1 
             ? climaxVolBullColor 
             : volWeight == 2 
               ? aboveAvgVolBullColor 
               : standardVolBullColor
        else
            volWeight == 1 
             ? climaxVolBearColor 
             : volWeight == 2 
               ? aboveAvgVolBearColor 
               : standardVolBearColor
    else
        _close > _open ? climaxVolBullColor : climaxVolBearColor

_getVolumeWeight(_open, _high, _low, _close, _vol) => 
    // The math below matches MT4 PVSRA indicator source
    avgVol = sma(_vol, 10)
    volWeightedPriceSpread = _vol * (_high - _low)
    highestVolWeightedPriceSpread = highest(volWeightedPriceSpread, 10)

    isClimaxVolume = _vol >= (avgVol * 2) or volWeightedPriceSpread >= highestVolWeightedPriceSpread
    isAboveAvgVolume = _vol >= avgVol * 1.5 and not isClimaxVolume
    volWeight = isClimaxVolume ? 1 : isAboveAvgVolume ? 2 : 0

_getColorByValues(_open, _high, _low, _close, _volume) =>
    volWeight = _getVolumeWeight(_open, _high, _low, _close, _volume)
    barColor = _getBarColorByVolWeight(volWeight, _open, _close)

_getColorAtResolution(_resolution) => 
    _color = _security(
         _getColorByValues(open, high, low, close, volume), 
         _resolution
         )

var line[] meterLines = array.new_line(0)
var label[] meterLabels = array.new_label(0)

_isValidTimeframeForMeterLabel(_resolution, _multiplier) => 
    if _resolution == '1'
        _multiplier <= 1
    else if _resolution == '5'
        _multiplier <= 5
    else if _resolution == '15'
        _multiplier <= 15
    else if _resolution == '30'
        _multiplier <= 30
    else if _resolution == '60'
        _multiplier <= 60
    else if _resolution == '240'
        _multiplier <= 240
    else if _resolution == 'D'
        _multiplier <= 1440
    else if _resolution == 'W'
        _multiplier <= (1440 * 7)
    else if _resolution == 'M'
        _multiplier <= (1440 * 7 * 30)

_drawMeterLabel(_resolution, index, labelsArray, isNew) => 
    _isValidTF = _isValidTimeframeForMeterLabel(_resolution, _getTimeframeMultiplier())
    _color = _isValidTF ? _getColorAtResolution(_resolution) : disabledMeterColor
    
    _initialOffest = meterLabelOffset
    _currentOffset = index * meterLabelWidthInBars
    _totalOffset = meterLabelOffset + _currentOffset
    _labelTime = _getTimeNBarsFromNow(_totalOffset)

    // _avgRange = sma(high - low, 20)
    // _verticalMargin = _avgRange * meterMarginMultiple
    // _y = highest(high, 100) + _verticalMargin
    _y = ema(close, 50)

    labelId = label.new(
         x=_labelTime,
         y=_y,
         text=_isValidTF ? _resolution : 'n/a',
         textcolor=_color,
         style=labelStyle,
         size=meterLabelSize,
         xloc=xloc.bar_time)

    array.push(labelsArray, labelId)

    // cleanup
    if not isNew 
        labelToDelete = array.shift(labelsArray)
        label.delete(labelToDelete)

_drawMeterLines() => 
    isNew = array.size(meterLabels) == 0
    
    _drawMeterLabel('1', 1, meterLabels, isNew)
    _drawMeterLabel('5', 2, meterLabels, isNew)
    _drawMeterLabel('15', 3, meterLabels, isNew)
    _drawMeterLabel('30', 4, meterLabels, isNew)
    _drawMeterLabel('60', 5, meterLabels, isNew)
    _drawMeterLabel('240', 6, meterLabels, isNew)
    _drawMeterLabel('D', 7, meterLabels, isNew)
    _drawMeterLabel('W', 8, meterLabels, isNew)
    _drawMeterLabel('M', 9, meterLabels, isNew)

_drawMeterLines()